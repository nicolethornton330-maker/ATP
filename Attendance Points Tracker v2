#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Attendance Points Tracker - Desktop GUI (Tkinter + SQLite) v2
-------------------------------------------------------------
New in v2:
- Import Employees & Points from Excel with your exact headers
- Links points by numeric Employee ID
- Recalculates derived dates (last_point_date, perfect_bonus, rolloff_date)

Employees headers expected (from your sample):
  Employee #, Last Name, First Name, Last Point Date, Perfect Attendance Bonus,
  Point Total, 2 Month Rolloff Date, Point Notice

Points headers expected (from your sample):
  ID, EmployeeNumber, LastName, FirstName, PointedDate, PointedAmount,
  Reason, Note, YTDRollOffDate, YTDRolled, Point Total

Requires for Excel import/export:
  python -m pip install pandas openpyxl
"""

import sqlite3
from datetime import date, datetime, timedelta
import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# Optional imports for Excel (export + import)
try:
    import pandas as pd
    PANDAS_AVAILABLE = True
except Exception:
    PANDAS_AVAILABLE = False

DB_FILE = "attendance.db"

# ----------------------------
# Date Utilities
# ----------------------------
def add_months(d: date, months: int) -> date:
    y = d.year + (d.month - 1 + months) // 12
    m = (d.month - 1 + months) % 12 + 1
    if m in (1,3,5,7,8,10,12):
        dim = 31
    elif m in (4,6,9,11):
        dim = 30
    else:
        leap = (y % 4 == 0 and (y % 100 != 0 or y % 400 == 0))
        dim = 29 if leap else 28
    day = min(d.day, dim)
    return date(y, m, day)

def first_of_next_month(d: date) -> date:
    y = d.year + (1 if d.month == 12 else 0)
    m = 1 if d.month == 12 else d.month + 1
    return date(y, m, 1)

def compute_rolloff(last_point: date) -> date:
    base = add_months(last_point, 2)
    return first_of_next_month(base)

def compute_perfect_bonus(last_point: date) -> date:
    base = add_months(last_point, 3)
    return first_of_next_month(base)

# ----------------------------
# Database
# ----------------------------
SCHEMA = """
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS employees (
    employee_id     INTEGER PRIMARY KEY,         -- numeric IDs (yours)
    name            TEXT NOT NULL,
    hire_date       DATE,
    last_point_date DATE,
    perfect_bonus   DATE,
    rolloff_date    DATE
);

CREATE TABLE IF NOT EXISTS points (
    point_id    INTEGER PRIMARY KEY AUTOINCREMENT,
    employee_id INTEGER NOT NULL,
    date        DATE NOT NULL,
    value       REAL NOT NULL CHECK (value IN (0.5, 1.0)),
    reason      TEXT,
    note        TEXT,
    flag        TEXT,
    FOREIGN KEY(employee_id) REFERENCES employees(employee_id) ON DELETE CASCADE
);
"""

def get_conn():
    return sqlite3.connect(DB_FILE)

def init_db():
    with get_conn() as conn:
        conn.executescript(SCHEMA)

def get_employees(conn):
    cur = conn.execute(
        "SELECT employee_id, name, hire_date, last_point_date, perfect_bonus, rolloff_date "
        "FROM employees ORDER BY name;"
    )
    return cur.fetchall()

def employee_exists(conn, employee_id: int) -> bool:
    cur = conn.execute("SELECT 1 FROM employees WHERE employee_id = ?;", (employee_id,))
    return cur.fetchone() is not None

def insert_employee(conn, name, hire_date=None, employee_id=None, last_point_date=None):
    if employee_id is None:
        conn.execute("INSERT INTO employees (name, hire_date) VALUES (?, ?);", (name, hire_date))
    else:
        conn.execute(
            "INSERT OR IGNORE INTO employees (employee_id, name, hire_date, last_point_date) "
            "VALUES (?, ?, ?, ?);",
            (employee_id, name, hire_date, last_point_date),
        )
    conn.commit()

def get_points_for_employee(conn, employee_id):
    cur = conn.execute(
        "SELECT point_id, date, value, reason, note, flag FROM points "
        "WHERE employee_id = ? ORDER BY date DESC, point_id DESC;",
        (employee_id,),
    )
    return cur.fetchall()

def insert_point(conn, employee_id, date_str, value, reason, note, flag):
    conn.execute(
        "INSERT INTO points (employee_id, date, value, reason, note, flag) "
        "VALUES (?, ?, ?, ?, ?, ?);",
        (employee_id, date_str, value, reason, note, flag),
    )
    conn.commit()
    recalc_employee_dates(conn, employee_id)

def recalc_employee_dates(conn, employee_id):
    cur = conn.execute("SELECT MAX(date) FROM points WHERE employee_id = ?;", (employee_id,))
    row = cur.fetchone()
    last_point = row[0]
    if last_point is None:
        conn.execute(
            "UPDATE employees SET last_point_date=NULL, perfect_bonus=NULL, rolloff_date=NULL "
            "WHERE employee_id = ?;",
            (employee_id,),
        )
        conn.commit()
        return

    lp = datetime.strptime(last_point, "%Y-%m-%d").date()
    rolloff = compute_rolloff(lp)
    bonus = compute_perfect_bonus(lp)

    today = date.today()
    while rolloff <= today:
        rolloff = add_months(rolloff, 2)
    while bonus <= today:
        bonus = add_months(bonus, 3)

    conn.execute(
        "UPDATE employees SET last_point_date=?, perfect_bonus=?, rolloff_date=? "
        "WHERE employee_id = ?;",
        (lp.isoformat(), bonus.isoformat(), rolloff.isoformat(), employee_id),
    )
    conn.commit()

def recalc_all_employees(conn):
    cur = conn.execute("SELECT employee_id FROM employees;")
    for (emp_id,) in cur.fetchall():
        recalc_employee_dates(conn, emp_id)

def rolloff_points_older_than(conn, days: int):
    cutoff = (date.today() - timedelta(days=days)).isoformat()
    conn.execute("DELETE FROM points WHERE date < ?;", (cutoff,))
    conn.commit()
    recalc_all_employees(conn)

# ----------------------------
# Excel Import/Export
# ----------------------------
def parse_date(value):
    """Parse Excel-ish date to YYYY-MM-DD string or None."""
    if value is None:
        return None
    if PANDAS_AVAILABLE:
        dt = pd.to_datetime(value, errors="coerce")
        if pd.isna(dt):
            return None
        try:
            return dt.date().isoformat()
        except Exception:
            return None
    # Fallback manual parse if pandas not installed (import may be disabled anyway)
    s = str(value).strip()
    if not s:
        return None
    for fmt in ("%Y-%m-%d", "%m/%d/%Y", "%m/%d/%y", "%d-%b-%Y"):
        try:
            return datetime.strptime(s, fmt).date().isoformat()
        except Exception:
            continue
    return None

def import_from_excel(conn, emp_path: str, points_path: str):
    if not PANDAS_AVAILABLE:
        raise RuntimeError("pandas/openpyxl required. Install via: python -m pip install pandas openpyxl")

    # Employees
    emp_df = pd.read_excel(emp_path, dtype={"Employee #": "Int64"})
    needed_emp = ["Employee #", "Last Name", "First Name"]
    for col in needed_emp:
        if col not in emp_df.columns:
            raise ValueError(f"Employees file missing required column: {col}")

    emp_added = 0
    for _, r in emp_df.iterrows():
        emp_id = r.get("Employee #")
        if pd.isna(emp_id):
            continue
        emp_id = int(emp_id)

        first = str(r.get("First Name", "") or "").strip()
        last  = str(r.get("Last Name", "") or "").strip()
        name  = (first + " " + last).strip() if (first or last) else f"Employee {emp_id}"
        last_point_date = parse_date(r.get("Last Point Date", None))

        if not employee_exists(conn, emp_id):
            insert_employee(conn, name=name, hire_date=None, employee_id=emp_id, last_point_date=last_point_date)
            emp_added += 1
        else:
            conn.execute(
                "UPDATE employees SET name = COALESCE(?, name), "
                "last_point_date = COALESCE(?, last_point_date) "
                "WHERE employee_id = ?;",
                (name, last_point_date, emp_id),
            )
            conn.commit()

    # Points
    pts_df = pd.read_excel(points_path, dtype={"EmployeeNumber": "Int64"})
    needed_pts = ["EmployeeNumber", "PointedDate", "PointedAmount"]
    for col in needed_pts:
        if col not in pts_df.columns:
            raise ValueError(f"Points file missing required column: {col}")

    pts_added, pts_skipped = 0, 0
    for _, r in pts_df.iterrows():
        emp_id = r.get("EmployeeNumber")
        if pd.isna(emp_id):
            pts_skipped += 1
            continue
        emp_id = int(emp_id)

        if not employee_exists(conn, emp_id):
            insert_employee(conn, name=f"Employee {emp_id}", employee_id=emp_id)

        ds = parse_date(r.get("PointedDate", None))
        if not ds:
            pts_skipped += 1
            continue

        try:
            val = float(r.get("PointedAmount", None))
            if val not in (0.5, 1.0):
                pts_skipped += 1
                continue
        except Exception:
            pts_skipped += 1
            continue

        reason = r.get("Reason", None)
        note   = r.get("Note", None)
        reason = None if (reason is None or (isinstance(reason, float) and str(reason) == "nan")) else str(reason)
        note   = None if (note   is None or (isinstance(note,   float) and str(note)   == "nan")) else str(note)
        flag   = None  # not present in sample

        conn.execute(
            "INSERT INTO points (employee_id, date, value, reason, note, flag) "
            "VALUES (?, ?, ?, ?, ?, ?);",
            (emp_id, ds, val, reason, note, flag),
        )
        pts_added += 1

    conn.commit()
    recalc_all_employees(conn)
    return emp_added, pts_added, pts_skipped

# ----------------------------
# GUI
# ----------------------------
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Attendance Points Tracker (v2)")
        self.geometry("1100x650")
        self.resizable(True, True)

        self.conn = get_conn()
        init_db()

        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=1)

        self.nav = ttk.Frame(self, padding=8)
        self.nav.grid(row=0, column=0, sticky="ns")
        self.content = ttk.Frame(self, padding=8)
        self.content.grid(row=0, column=1, sticky="nsew")
        self.content.rowconfigure(0, weight=1)
        self.content.columnconfigure(0, weight=1)

        ttk.Label(self.nav, text="Menu", font=("Segoe UI", 12, "bold")).pack(pady=(0,6))
        ttk.Button(self.nav, text="Employees",   command=self.show_employees).pack(fill="x", pady=2)
        ttk.Button(self.nav, text="Points",      command=self.show_points).pack(fill="x", pady=2)
        ttk.Button(self.nav, text="Reports",     command=self.show_reports).pack(fill="x", pady=2)
        ttk.Button(self.nav, text="Maintenance", command=self.show_maintenance).pack(fill="x", pady=2)
        ttk.Separator(self.nav, orient="horizontal").pack(fill="x", pady=6)
        ttk.Button(self.nav, text="Exit",        command=self.destroy).pack(fill="x", pady=2)

        self.current_frame = None
        self.show_employees()

    def swap_content(self, frame_class):
        if self.current_frame is not None:
            self.current_frame.destroy()
        self.current_frame = frame_class(self.content, self.conn)
        self.current_frame.grid(row=0, column=0, sticky="nsew")

    def show_employees(self):  self.swap_content(EmployeesFrame)
    def show_points(self):     self.swap_content(PointsFrame)
    def show_reports(self):    self.swap_content(ReportsFrame)
    def show_maintenance(self):self.swap_content(MaintenanceFrame)

class EmployeesFrame(ttk.Frame):
    def __init__(self, parent, conn):
        super().__init__(parent)
        self.conn = conn
        self.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)

        form = ttk.LabelFrame(self, text="Add Employee", padding=8)
        form.grid(row=0, column=0, sticky="ew", pady=(0,8))

        ttk.Label(form, text="Employee ID (numeric)").grid(row=0, column=0, sticky="w")
        self.empid_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.empid_var, width=12).grid(row=0, column=1, sticky="w", padx=6)

        ttk.Label(form, text="Name").grid(row=0, column=2, sticky="w")
        self.name_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.name_var, width=30).grid(row=0, column=3, sticky="w", padx=6)

        ttk.Label(form, text="Hire Date (YYYY-MM-DD, optional)").grid(row=0, column=4, sticky="w")
        self.hire_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.hire_var, width=16).grid(row=0, column=5, sticky="w", padx=6)

        ttk.Button(form, text="Add", command=self.add_employee).grid(row=0, column=6, padx=8)

        cols = ("employee_id","name","hire_date","last_point_date","perfect_bonus","rolloff_date")
        self.tree = ttk.Treeview(self, columns=cols, show="headings", height=18)
        for c in cols:
            self.tree.heading(c, text=c.replace("_"," ").title())
            self.tree.column(c, width=150 if c!="name" else 220, anchor="center")
        self.tree.grid(row=1, column=0, sticky="nsew")

        self.refresh_table()

    def refresh_table(self):
        for r in self.tree.get_children():
            self.tree.delete(r)
        for row in get_employees(self.conn):
            self.tree.insert("", "end", values=row)

    def add_employee(self):
        empid_s = self.empid_var.get().strip()
        if not empid_s.isdigit():
            messagebox.showwarning("Validation", "Employee ID must be numeric.")
            return
        emp_id = int(empid_s)

        name = self.name_var.get().strip()
        if not name:
            messagebox.showwarning("Validation", "Please enter a name.")
            return

        hire = self.hire_var.get().strip() or None
        if hire:
            try:
                datetime.strptime(hire, "%Y-%m-%d")
            except ValueError:
                messagebox.showwarning("Validation", "Hire date must be YYYY-MM-DD or empty.")
                return

        if employee_exists(self.conn, emp_id):
            messagebox.showwarning("Exists", f"Employee {emp_id} already exists.")
            return

        insert_employee(self.conn, name, hire_date=hire, employee_id=emp_id)
        self.empid_var.set(""); self.name_var.set(""); self.hire_var.set("")
        self.refresh_table()
        messagebox.showinfo("Success", "Employee added.")

class PointsFrame(ttk.Frame):
    def __init__(self, parent, conn):
        super().__init__(parent)
        self.conn = conn
        self.columnconfigure(0, weight=1)
        self.rowconfigure(2, weight=1)

        form = ttk.LabelFrame(self, text="Add Point", padding=8)
        form.grid(row=0, column=0, sticky="ew", pady=(0,8))

        ttk.Label(form, text="Employee ID").grid(row=0, column=0, sticky="w")
        self.empid_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.empid_var, width=12).grid(row=0, column=1, padx=6)

        ttk.Label(form, text="Date (YYYY-MM-DD)").grid(row=0, column=2, sticky="w")
        self.date_var = tk.StringVar(value=date.today().isoformat())
        ttk.Entry(form, textvariable=self.date_var, width=16).grid(row=0, column=3, padx=6)

        ttk.Label(form, text="Value (0.5 or 1.0)").grid(row=0, column=4, sticky="w")
        self.value_var = tk.StringVar(value="1.0")
        ttk.Combobox(form, textvariable=self.value_var, values=["0.5","1.0"], width=6, state="readonly").grid(row=0, column=5, padx=6)

        ttk.Label(form, text="Reason").grid(row=1, column=0, sticky="w")
        self.reason_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.reason_var, width=30).grid(row=1, column=1, padx=6, sticky="w")

        ttk.Label(form, text="Note").grid(row=1, column=2, sticky="w")
        self.note_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.note_var, width=30).grid(row=1, column=3, padx=6, sticky="w")

        ttk.Label(form, text="Flag (optional)").grid(row=1, column=4, sticky="w")
        self.flag_var = tk.StringVar()
        ttk.Entry(form, textvariable=self.flag_var, width=10).grid(row=1, column=5, padx=6, sticky="w")

        ttk.Button(form, text="Add Point", command=self.add_point).grid(row=0, column=6, rowspan=2, padx=8)

        table_box = ttk.LabelFrame(self, text="Recent Points (All Employees)", padding=8)
        table_box.grid(row=1, column=0, sticky="nsew")

        cols = ("point_id","employee_id","date","value","reason","note","flag")
        self.tree = ttk.Treeview(table_box, columns=cols, show="headings", height=14)
        for c in cols:
            self.tree.heading(c, text=c.title().replace("_"," "))
            self.tree.column(c, width=120 if c not in ("reason","note") else 250, anchor="center")
        self.tree.pack(fill="both", expand=True)

        bottom = ttk.Frame(self); bottom.grid(row=2, column=0, sticky="ew", pady=6)
        ttk.Button(bottom, text="Refresh", command=self.refresh_table).pack(side="left")

        self.refresh_table()

    def refresh_table(self):
        for r in self.tree.get_children():
            self.tree.delete(r)
        cur = self.conn.execute(
            "SELECT point_id, employee_id, date, value, reason, note, flag "
            "FROM points ORDER BY date DESC, point_id DESC LIMIT 200;"
        )
        for row in cur.fetchall():
            self.tree.insert("", "end", values=row)

    def add_point(self):
        empid_s = self.empid_var.get().strip()
        if not empid_s.isdigit():
            messagebox.showwarning("Validation", "Employee ID must be numeric.")
            return
        emp_id = int(empid_s)

        ds = self.date_var.get().strip()
        try:
            datetime.strptime(ds, "%Y-%m-%d")
        except ValueError:
            messagebox.showwarning("Validation", "Date must be YYYY-MM-DD.")
            return

        try:
            val = float(self.value_var.get())
            if val not in (0.5, 1.0):
                raise ValueError
        except Exception:
            messagebox.showwarning("Validation", "Value must be 0.5 or 1.0.")
            return

        reason = self.reason_var.get().strip() or None
        note   = self.note_var.get().strip() or None
        flag   = self.flag_var.get().strip() or None

        if not employee_exists(self.conn, emp_id):
            messagebox.showwarning("Validation", f"Employee {emp_id} does not exist.")
            return

        insert_point(self.conn, emp_id, ds, val, reason, note, flag)
        self.refresh_table()
        messagebox.showinfo("Success", "Point added and dates recalculated.")

class ReportsFrame(ttk.Frame):
    def __init__(self, parent, conn):
        super().__init__(parent)
        self.conn = conn
        self.columnconfigure(0, weight=1)

        ttk.Label(self, text="Export Reports to Excel", font=("Segoe UI", 12, "bold")).grid(row=0, column=0, sticky="w", pady=(0,6))
        ttk.Button(self, text="Export to Excel (.xlsx)", command=self.export_to_excel).grid(row=1, column=0, sticky="w")
        ttk.Label(self, text="Creates a workbook with 'Employees', 'Points', and 'Summary' sheets.").grid(row=2, column=0, sticky="w", pady=6)

        if not PANDAS_AVAILABLE:
            ttk.Label(self, foreground="red", text="Note: pandas/openpyxl not found. Install with:\n  python -m pip install pandas openpyxl").grid(row=3, column=0, sticky="w")

    def export_to_excel(self):
        if not PANDAS_AVAILABLE:
            messagebox.showerror("Missing Libraries", "Please install 'pandas' and 'openpyxl' to export Excel.\n\nRun:\n  python -m pip install pandas openpyxl")
            return

        fpath = filedialog.asksaveasfilename(
            defaultextension=".xlsx", filetypes=[("Excel Workbook","*.xlsx")],
            title="Save Excel Report As"
        )
        if not fpath:
            return

        try:
            with get_conn() as conn:
                emp_df = pd.read_sql_query("""
                    SELECT employee_id, name, hire_date, last_point_date, perfect_bonus, rolloff_date
                    FROM employees ORDER BY name;
                """, conn)

                pts_df = pd.read_sql_query("""
                    SELECT p.point_id, p.employee_id, e.name AS employee_name, p.date, p.value, p.reason, p.note, p.flag
                    FROM points p
                    JOIN employees e ON e.employee_id = p.employee_id
                    ORDER BY p.date DESC, p.point_id DESC;
                """, conn)

                summary_df = pd.read_sql_query("""
                    SELECT e.employee_id, e.name,
                           COALESCE(ROUND(SUM(p.value), 2), 0.0) AS total_points,
                           e.last_point_date, e.perfect_bonus, e.rolloff_date
                    FROM employees e
                    LEFT JOIN points p ON p.employee_id = e.employee_id
                    GROUP BY e.employee_id, e.name, e.last_point_date, e.perfect_bonus, e.rolloff_date
                    ORDER BY e.name;
                """, conn)

            with pd.ExcelWriter(fpath, engine="openpyxl") as writer:
                emp_df.to_excel(writer, sheet_name="Employees", index=False)
                pts_df.to_excel(writer, sheet_name="Points", index=False)
                summary_df.to_excel(writer, sheet_name="Summary", index=False)

            messagebox.showinfo("Export Complete", f"Excel report created:\n{fpath}")
        except Exception as ex:
            messagebox.showerror("Export Error", f"Could not export Excel:\n{ex}")

class MaintenanceFrame(ttk.Frame):
    def __init__(self, parent, conn):
        super().__init__(parent)
        self.conn = conn
        self.columnconfigure(0, weight=1)

        ttk.Label(self, text="Maintenance", font=("Segoe UI", 12, "bold")).grid(row=0, column=0, sticky="w", pady=(0,6))
        ttk.Button(self, text="Import Employees & Points from Excel", command=self.import_excel).grid(row=1, column=0, sticky="w", pady=4)
        ttk.Button(self, text="Roll off points older than 2 months", command=self.rolloff_2m).grid(row=2, column=0, sticky="w", pady=4)
        ttk.Button(self, text="Roll off points older than 1 year", command=self.rolloff_1y).grid(row=3, column=0, sticky="w", pady=4)
        ttk.Button(self, text="Recalculate all derived dates", command=self.recalc_all).grid(row=4, column=0, sticky="w", pady=12)

        if not PANDAS_AVAILABLE:
            ttk.Label(self, foreground="red", text="Note: pandas/openpyxl not found. Install with:\n  python -m pip install pandas openpyxl").grid(row=5, column=0, sticky="w")

        ttk.Label(self, text=("Importer expects headers:\n"
                              "Employees: Employee #, Last Name, First Name, Last Point Date, ...\n"
                              "Points: EmployeeNumber, PointedDate, PointedAmount, Reason, Note, ...")
                 ).grid(row=6, column=0, sticky="w", pady=6)

    def import_excel(self):
        if not PANDAS_AVAILABLE:
            messagebox.showerror("Missing Libraries", "Please install 'pandas' and 'openpyxl' first:\n\npython -m pip install pandas openpyxl")
            return
        emp_path = filedialog.askopenfilename(title="Select Employees Excel", filetypes=[("Excel files","*.xlsx *.xls")])
        if not emp_path:
            return
        pts_path = filedialog.askopenfilename(title="Select Points Excel", filetypes=[("Excel files","*.xlsx *.xls")])
        if not pts_path:
            return

        try:
            emp_added, pts_added, pts_skipped = import_from_excel(self.conn, emp_path, pts_path)
            messagebox.showinfo("Import Complete",
                                f"Imported {emp_added} employees and {pts_added} points.\n"
                                f"Skipped {pts_skipped} point rows (invalid/missing data).")
        except Exception as ex:
            messagebox.showerror("Import Error", f"Could not import data:\n{ex}")

    def rolloff_2m(self):
        rolloff_points_older_than(self.conn, days=60)
        messagebox.showinfo("Rolloff Complete", "Removed points older than ~2 months and recalculated.")
    
    def rolloff_1y(self):
        rolloff_points_older_than(self.conn, days=365)
        messagebox.showinfo("Rolloff Complete", "Removed points older than 1 year and recalculated.")

    def recalc_all(self):
        recalc_all_employees(self.conn)
        messagebox.showinfo("Recalculation Complete", "Recalculated dates for all employees.")

# ----------------------------
# Entry
# ----------------------------
def main():
    init_db()
    app = App()
    app.mainloop()

if __name__ == "__main__":
    main()
